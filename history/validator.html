<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>15-Puzzle Solver</title>
    <!-- GIF.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #4b3f3b;
            color: #f0f0f0;
        }
        h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }
        .input-container {
            margin-top: 20px;
        }
        input[type="text"] {
            width: 400px;
            padding: 10px;
            font-size: 1em;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        button {
            background-color: #a48c7a;
            color: #f0f0f0;
            border: none;
            padding: 10px 20px;
            font-size: 1em;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }
        button:hover {
            background-color: #8b7562;
        }
        .board {
            display: grid;
            grid-template-columns: repeat(4, 60px);
            gap: 10px;
            margin-top: 20px;
            background-color: #6b5e55;
            padding: 15px;
            border-radius: 10px;
        }
        .tile {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #e6d7c3;
            color: #4b3f3b;
            font-size: 1.5em;
            font-weight: bold;
            border-radius: 5px;
        }
        .tile.empty {
            background-color: #C9BCAD;
        }
        .tile.highlight {
            background-color: #ffeb3b;
        }
        #result {
            margin-top: 20px;
            font-size: 1.5em;
            font-weight: bold;
        }
        #result.solvable {
            color: #00cc00;
        }
        #result.unsolvable {
            color: #cc0000;
        }
        canvas {
            display: none;
        }
    </style>
</head>
<body>
    <h1>15-Puzzle Solver</h1>
    <div class="input-container">
        <label for="boardInput">Enter the board state as a formatted array</label><br>
        <input type="text" id="boardInput" placeholder="[6, 1, 13, 2, 14, 15, 10, 3, 5, 8, 9, 4, 11, 0, 12, 7]">
        <button onclick="checkSolvability()">Validate Board</button>
    </div>
    <div id="board" class="board"></div>
    <div id="result"></div>
    <button id="solveButton" onclick="solveBoard()" style="display:none;">Solve</button>
    <canvas id="boardCanvas" width="300" height="300"></canvas>
    <div id="gifContainer"></div>

    <script>
        let solutionPath = [];
        let currentStep = 0;
        let isSolving = false; // Flag to prevent multiple solves

        /**
         * Renders the board state to the DOM and optionally adds a frame to the GIF.
         * @param {Array} board - The current board state.
         * @param {boolean} isGifFrame - Whether to capture this render as a GIF frame.
         * @param {number} highlightIndex - The index of the tile to highlight.
         */
        function renderBoard(board, isGifFrame = false, highlightIndex = -1) {
            const boardDiv = document.getElementById("board");
            boardDiv.innerHTML = "";
            board.forEach((value, index) => {
                const tile = document.createElement("div");
                tile.classList.add("tile");
                if (value === 0) {
                    tile.classList.add("empty");
                    tile.textContent = "";
                } else {
                    tile.textContent = value;
                }
                if (index === highlightIndex) {
                    tile.classList.add("highlight");
                }
                boardDiv.appendChild(tile);
            });

            if (isGifFrame) {
                renderToCanvas(board, highlightIndex);
            }
        }

        /**
         * Renders the board state to a hidden canvas for GIF creation.
         * @param {Array} board - The current board state.
         * @param {number} highlightIndex - The index of the tile to highlight.
         */
        function renderToCanvas(board, highlightIndex = -1) {
            const canvas = document.getElementById("boardCanvas");
            const ctx = canvas.getContext("2d", { willReadFrequently: true });
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const tileSize = 60;
            const gap = 10;
            const boardPadding = 15;

            // Draw board background
            ctx.fillStyle = "#6b5e55";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            board.forEach((value, index) => {
                const row = Math.floor(index / 4);
                const col = index % 4;
                const x = boardPadding + col * (tileSize + gap);
                const y = boardPadding + row * (tileSize + gap);

                ctx.fillStyle = index === highlightIndex ? "#ffeb3b" : value === 0 ? "#d9c7b6" : "#e6d7c3";
                ctx.fillRect(x, y, tileSize, tileSize);
                ctx.strokeStyle = "#6b5e55";
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, tileSize, tileSize);

                if (value !== 0) {
                    ctx.fillStyle = "#4b3f3b";
                    ctx.font = "bold 30px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(value, x + tileSize / 2, y + tileSize / 2);
                }
            });
        }

        /**
         * Determines if a given board state is solvable.
         * @param {Array} board - The board state to check.
         * @returns {boolean} - True if solvable, false otherwise.
         */
        function isSolvable(board) {
            const size = 4;
            let inversionCount = 0;
            const boardLength = board.length;

            for (let i = 0; i < boardLength; i++) {
                for (let j = i + 1; j < boardLength; j++) {
                    if (board[i] !== 0 && board[j] !== 0 && board[i] > board[j]) {
                        inversionCount++;
                    }
                }
            }

            const blankIndex = board.indexOf(0);
            if (blankIndex === -1) {
                throw new Error("The board must contain a blank tile represented by 0.");
            }

            const blankRowFromBottom = size - Math.floor(blankIndex / size);

            if (size % 2 === 1) {
                return inversionCount % 2 === 0;
            } else {
                return (inversionCount + blankRowFromBottom) % 2 === 1;
            }
        }

        /**
         * Validates the input board and initializes the solving process if solvable.
         */
        function checkSolvability() {
            const boardInput = document.getElementById("boardInput").value;
            let board;

            try {
                board = JSON.parse(boardInput);
                if (!Array.isArray(board) || board.length !== 16) {
                    throw new Error();
                }
                const uniqueSet = new Set(board);
                if (uniqueSet.size !== 16 || !uniqueSet.has(0)) {
                    throw new Error();
                }
            } catch (error) {
                document.getElementById("result").textContent = "Invalid board state. Please enter a valid list with exactly 16 unique numbers including 0.";
                document.getElementById("result").className = "";
                document.getElementById("solveButton").style.display = "none";
                return;
            }

            renderBoard(board);

            const solvable = isSolvable(board);
            const resultDiv = document.getElementById("result");
            resultDiv.textContent = solvable ? "Solvable!" : "Unsolvable";
            resultDiv.className = solvable ? "solvable" : "unsolvable";

            if (solvable) {
                document.getElementById("solveButton").style.display = "inline-block";
                // Run IDA* search asynchronously using a Web Worker
                runIDAStarWorker(board.slice());
            } else {
                document.getElementById("solveButton").style.display = "none";
            }
        }

        /**
         * Initializes a Web Worker to run the IDA* Search algorithm asynchronously.
         * @param {Array} board - The initial board state.
         */
        function runIDAStarWorker(board) {
            // Disable the Validate button to prevent multiple runs
            const validateButton = document.querySelector('button[onclick="checkSolvability()"]');
            validateButton.disabled = true;
            document.getElementById("result").textContent = "Solving...";
            solutionPath = [];
            currentStep = 0;

            // Create a new Web Worker
            const worker = new Worker('solverWorker.js');

            // Listen for messages (solution path) from the worker
            worker.onmessage = function(e) {
                solutionPath = e.data;
                if (solutionPath.length === 0) {
                    document.getElementById("result").textContent = "No solution found.";
                    document.getElementById("result").className = "unsolvable";
                    document.getElementById("solveButton").style.display = "none";
                } else {
                    document.getElementById("result").textContent = `Solvable! Number of moves: ${solutionPath.length - 1}`;
                    document.getElementById("result").className = "solvable";
                }
                validateButton.disabled = false;
                worker.terminate();
            };

            // Handle any errors from the worker
            worker.onerror = function(error) {
                console.error("Worker error:", error);
                document.getElementById("result").textContent = "An error occurred during solving.";
                document.getElementById("result").className = "unsolvable";
                document.getElementById("solveButton").style.display = "none";
                validateButton.disabled = false;
                worker.terminate();
            };

            // Send the initial board state to the worker
            worker.postMessage(board);
        }

        /**
         * Animates the solving process by iterating through the solution path.
         */
        async function solveBoard() {
            if (solutionPath.length === 0) {
                alert("No solution path available.");
                return;
            }

            if (isSolving) {
                alert("A solve operation is already in progress.");
                return;
            }

            isSolving = true;

            // Disable the Solve button to prevent multiple runs
            const solveButton = document.getElementById("solveButton");
            solveButton.disabled = true;
            solveButton.textContent = "Solving...";

            // Clear previous GIF frames and container
            document.getElementById('gifContainer').innerHTML = '';

            // Create a new GIF instance
            const gif = new GIF({
                workers: 2,
                quality: 10,
                workerScript: 'gif.worker.js' // Ensure this path is correct
            });

            // Handle the 'finished' event to display the GIF
            gif.on('finished', function(blob) {
                const img = document.createElement('img');
                img.src = URL.createObjectURL(blob);
                img.alt = "Solution GIF";
                img.style.marginTop = "20px";
                const gifContainer = document.getElementById('gifContainer');
                gifContainer.innerHTML = '';
                gifContainer.appendChild(img);

                // Re-enable the Solve button
                solveButton.disabled = false;
                solveButton.textContent = "Solve";
                isSolving = false;
            });

            // Handle any errors during GIF creation
            gif.on('error', function(error) {
                console.error("GIF.js error:", error);
                alert("An error occurred while creating the GIF.");
                // Re-enable the Solve button
                solveButton.disabled = false;
                solveButton.textContent = "Solve";
                isSolving = false;
            });

            for (let step = 0; step < solutionPath.length; step++) {
                if (step === 0) {
                    // Initial state: highlight the first move
                    const currentState = solutionPath[step];
                    const nextState = solutionPath[step + 1];
                    if (nextState) {
                        const highlightIndex = currentState.findIndex(
                            (value, index) => value !== nextState[index] && value !== 0
                        );
                        renderBoard(currentState, true, highlightIndex);
                        gif.addFrame(document.getElementById('boardCanvas'), { delay: 500, copy: true });
                    } else {
                        renderBoard(currentState, true);
                        gif.addFrame(document.getElementById('boardCanvas'), { delay: 500, copy: true });
                    }
                } else {
                    const previousState = solutionPath[step - 1];
                    const currentState = solutionPath[step];
                    const highlightIndex = previousState.findIndex(
                        (value, index) => value !== currentState[index] && value !== 0
                    );

                    // Highlight the tile before it is moved
                    renderBoard(previousState, true, highlightIndex);
                    gif.addFrame(document.getElementById('boardCanvas'), { delay: 500, copy: true });
                    await delay(500); // Wait for 0.5 seconds

                    // Render the new state without highlighting
                    renderBoard(currentState, true);
                    gif.addFrame(document.getElementById('boardCanvas'), { delay: 500, copy: true });
                }

                await delay(500); // Wait for 0.5 seconds before next step
            }

            // After all steps, render the GIF
            try {
                gif.render();
            } catch (error) {
                console.error("GIF.render() error:", error);
                alert("An error occurred while rendering the GIF.");
                // Re-enable the Solve button
                solveButton.disabled = false;
                solveButton.textContent = "Solve";
                isSolving = false;
            }
        }

        /**
         * Creates a delay for asynchronous operations.
         * @param {number} ms - The delay duration in milliseconds.
         * @returns {Promise} - A promise that resolves after the specified delay.
         */
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        /**
         * Handles the completion of GIF rendering by displaying the GIF.
         */
        // Removed global gif.on('finished') as it's now handled within solveBoard()

        // Your existing IDA* and other functions...

    </script>
</body>
</html>
